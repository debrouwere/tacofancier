// Generated by CoffeeScript 1.8.0
(function() {
  var AWS, async, behaved, categories, cheerio, context, download, env, exec, extract, extractWords, fs, getContributors, github, markdown, meats, processCategory, processRecipes, protein, read, request, s3, setup, toHTML, worker, writeRecipes, _,
    __slice = [].slice;

  _ = require('underscore');

  _.str = require('underscore.string');

  fs = require('fs');

  fs.path = require('path');

  fs.mkdirp = require('mkdirp');

  exec = require('child_process').exec;

  async = require('async');

  request = require('request');

  cheerio = require('cheerio');

  markdown = require('markdown').markdown;

  toHTML = _.bind(markdown.toHTML, markdown);

  AWS = require('aws-sdk');

  context = process.argv[2] === 'local' ? 'local' : 'remote';

  if (context === 'local') {
    env = process.env;
  } else {
    worker = require('ironworker-helper');
    env = worker.config;
  }

  AWS.config.update({
    accessKeyId: env.AWS_ACCESS_KEY_ID,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY,
    region: 'us-east-1'
  });

  s3 = new AWS.S3();

  categories = {
    base_layers: 'layers',
    full_tacos: 'tacos',
    like_tacos: 'more',
    condiments: 'condiments',
    mixins: 'mixins',
    seasonings: 'seasonings',
    shells: 'shells'
  };

  meats = ['beef', 'chicken', 'turkey', 'fish', 'pork', 'lamb'];

  protein = ['seitan', 'tempeh', 'tofu', 'quorn', 'soyrizo', 'tofurky'];

  github = 'https://api.github.com/repos/sinker/tacofancy/commits?';

  getContributors = function(path, callback) {
    var kvs, options, params, qs;
    options = {
      path: path,
      client_id: process.env.GITHUB_CLIENT_ID,
      client_secret: process.env.GITHUB_CLIENT_SECRET
    };
    kvs = _.map(options, function(value, key) {
      return "" + key + "=" + value;
    });
    qs = kvs.join('&');
    params = {
      headers: {
        'user-agent': 'stdbrouw/tacofancier'
      },
      uri: github + qs,
      json: true
    };
    return request.get(params, function(err, res, commits) {
      var author, contributors;
      if (err || res.statusCode !== 200) {
        return callback(err);
      }
      contributors = commits.map(function(commit) {
        var contributor, _ref;
        return contributor = {
          name: commit.commit.author.name,
          username: (_ref = commit.author) != null ? _ref.login : void 0
        };
      });
      contributors = _.unique(contributors, false, _.property('username'));
      author = _.last(contributors);
      return callback(null, {
        author: author,
        contributors: contributors
      });
    });
  };

  behaved = function(fn) {
    return function(first) {
      return fn(first);
    };
  };

  download = function(callback) {
    return fs.exists('tacofancy', function(exists) {
      if (exists) {
        return callback(null);
      } else {
        return exec('make tacofancy', function(err) {
          return callback(err);
        });
      }
    });
  };

  setup = function(callback) {
    return fs.mkdirp('data', behaved(callback));
  };

  read = function() {
    var path, segments, _ref;
    segments = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    segments = segments.filter(_.isString);
    path = (_ref = fs.path).join.apply(_ref, segments);
    return fs.readFileSync(path, {
      encoding: 'utf8'
    });
  };

  extractWords = function(dom) {
    return dom('h1,h2,h3,p').map(function() {
      return dom(this).text();
    }).get().join(' ').replace(/[^\w]/g, ' ').split(' ').map(function(str) {
      return str.toLowerCase();
    });
  };

  extract = function($) {
    var lastLine, metadata, words;
    words = extractWords($);
    lastLine = $('p').last().text();
    return metadata = {
      meats: _.intersection(meats, words),
      protein: _.intersection(protein, words),
      vegetarian: (_.str.contains(lastLine, 'vegetarian')) || protein.length > 0,
      vegan: _.str.contains(lastLine, 'vegan'),
      name: $('h1').text() || null
    };
  };

  processCategory = function(category, callback) {
    var fileRoot, html, metadata, paths, repoPaths, repoRoot, slugs;
    console.log("Figuring out the " + category + " situation.");
    fileRoot = fs.path.join('tacofancy', category);
    repoRoot = category;
    paths = fs.readdirSync(fileRoot).filter(function(path) {
      return (fs.path.extname(path)) === '.md';
    }).filter(function(path) {
      return !_.str.contains(path, 'README');
    });
    repoPaths = paths.map(function(path) {
      return fs.path.join(repoRoot, path);
    });
    slugs = paths.map(function(path) {
      return path.slice(0, -3);
    }).map(_.str.dasherize);
    markdown = paths.map(_.partial(read, fileRoot));
    html = markdown.map(behaved(toHTML));
    metadata = html.map(behaved(cheerio.load)).map(extract);
    return async.mapSeries(repoPaths, getContributors, function(err, authorship) {
      var data;
      if (err) {
        return callback(err);
      }
      data = _.zip(paths, slugs, markdown, html, metadata, authorship).map(function(_arg) {
        var authorship, html, markdown, metadata, path, slug;
        path = _arg[0], slug = _arg[1], markdown = _arg[2], html = _arg[3], metadata = _arg[4], authorship = _arg[5];
        return _.extend(metadata, authorship, {
          path: path,
          slug: slug,
          markdown: markdown,
          html: html,
          category: categories[category]
        });
      });
      return callback(null, data);
    });
  };

  processRecipes = function(callback) {
    return async.map(_.keys(categories), processCategory, function(err, recipes) {
      var categorizedRecipes;
      if (err) {
        return callback(err);
      }
      categorizedRecipes = _.object(_.zip(_.values(categories), recipes));
      return callback(null, categorizedRecipes);
    });
  };

  writeRecipes = function(recipes, callback) {
    var params, serialized;
    serialized = JSON.stringify(recipes, void 0, 2);
    if (context === 'local') {
      return fs.writeFile('data/all.json', serialized, {
        encoding: 'utf8'
      }, callback);
    } else {
      params = {
        Bucket: env.AWS_S3_BUCKET_NAME,
        Key: 'all.json',
        Body: serialized
      };
      return s3.putObject(params, callback);
    }
  };

  async.waterfall([download, setup, processRecipes, writeRecipes], function(err, recipes) {
    if (err) {
      console.log(err.message);
      throw new Error(err.message);
    } else {
      return console.log('Robot-readable recipes ready!');
    }
  });

}).call(this);
