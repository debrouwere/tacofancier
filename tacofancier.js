// Generated by CoffeeScript 1.8.0

/*
I want a pony: 

[ ] use github to figure out a recipe's author and contributors
[ ] output aggregations: vegan, vegetarian, protein type, meat type, category, everything
[ ] process links to figure out recipe relationships
 */

(function() {
  var async, behaved, categories, cheerio, download, extract, extractWords, fs, getContributors, github, markdown, meats, processCategory, processRecipes, protein, read, saveRecipes, setup, toHTML, _,
    __slice = [].slice;

  _ = require('underscore');

  _.str = require('underscore.string');

  fs = require('fs');

  fs.path = require('path');

  fs.mkdirp = require('mkdirp');

  async = require('async');

  cheerio = require('cheerio');

  markdown = require('markdown').markdown;

  toHTML = _.bind(markdown.toHTML, markdown);

  categories = {
    layers: 'base_layers',
    tacos: 'full_tacos',
    more: 'like_tacos',
    condiments: 'condiments',
    mixins: 'mixins',
    seasonings: 'seasonings',
    shells: 'shells'
  };

  meats = ['beef', 'chicken', 'turkey', 'fish', 'pork', 'lamb'];

  protein = ['seitan', 'tempeh', 'tofu', 'quorn', 'soyrizo', 'tofurky'];

  github = 'https://api.github.com/repos/sinker/tacofancy/commits';

  getContributors = function(path, callback) {
    var params;
    params = {
      uri: github,
      qs: {
        path: path
      },
      json: true
    };
    return request.get(params, function(err, res, commits) {
      var author, contributors;
      if (err) {
        return callback(err);
      }
      contributors = commits.map(function(commit) {
        var contributor;
        return contributor = {
          name: commit.commit.author.name,
          username: commit.author.login
        };
      });
      contributors = _.unique(contributors, false, _.property('username'));
      author = _.last(contributors);
      return callback(null, author, contributors);
    });
  };

  behaved = function(fn) {
    return function(first) {
      return fn(first);
    };
  };

  download = function(callback) {
    return fs.exists('tacofancy', function(exists) {
      if (exists) {
        return callback(null);
      } else {
        return exec('make tacofancy', function(err) {
          return callback(err);
        });
      }
    });
  };

  setup = function(callback) {
    return fs.mkdirp('data', behaved(callback));
  };

  read = function() {
    var path, segments, _ref;
    segments = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    segments = segments.filter(_.isString);
    path = (_ref = fs.path).join.apply(_ref, segments);
    return fs.readFileSync(path, {
      encoding: 'utf8'
    });
  };

  extractWords = function(dom) {
    return dom('h1,h2,h3,p').map(function() {
      return dom(this).text();
    }).get().join(' ').replace(/[^\w]/g, ' ').split(' ').map(function(str) {
      return str.toLowerCase();
    });
  };

  extract = function($) {
    var lastLine, metadata, words;
    words = extractWords($);
    lastLine = $('p').last().text();
    return metadata = {
      meats: _.intersection(meats, words),
      protein: _.intersection(protein, words),
      vegetarian: (_.str.contains(lastLine, 'vegetarian')) || protein.length > 0,
      vegan: _.str.contains(lastLine, 'vegan'),
      name: $('h1').text() || null
    };
  };

  processCategory = function(category) {
    var data, html, metadata, paths, root, slugs;
    console.log("Figuring out the " + category + " situation.");
    root = fs.path.join('tacofancy', category);
    paths = fs.readdirSync(root).filter(function(path) {
      return (fs.path.extname(path)) === '.md';
    }).filter(function(path) {
      return !_.str.contains(path, 'README');
    });
    slugs = paths.map(function(path) {
      return path.slice(0, -3);
    }).map(_.str.dasherize);
    markdown = paths.map(_.partial(read, root));
    html = markdown.map(behaved(toHTML));
    metadata = html.map(behaved(cheerio.load)).map(extract);
    data = _.zip(slugs, markdown, html, metadata).map(function(_arg) {
      var html, markdown, metadata, slug;
      slug = _arg[0], markdown = _arg[1], html = _arg[2], metadata = _arg[3];
      return _.extend(metadata, {
        slug: slug,
        markdown: markdown,
        html: html,
        category: categories[category]
      });
    });
    return data;
  };

  processRecipes = function(callback) {
    var categorizedRecipes, recipes;
    recipes = (_.values(categories)).map(processCategory);
    categorizedRecipes = _.object(_.zip(_.keys(categories), recipes));
    return callback(null, categorizedRecipes);
  };

  saveRecipes = function(recipes, callback) {
    var serialized;
    serialized = JSON.stringify(recipes, void 0, 2);
    return fs.writeFile('data/all.json', serialized, {
      encoding: 'utf8'
    }, callback);
  };

  async.waterfall([download, setup, processRecipes, saveRecipes], function(err) {
    console.log('Robot-readable recipes ready!');
    if (process.argv[2] !== 'local') {
      return exec('zip, sync ./data to s3');
    }
  });

}).call(this);
